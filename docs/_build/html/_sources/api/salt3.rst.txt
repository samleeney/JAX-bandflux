SALT3 Module
===========

.. automodule:: jax_supernovae.salt3
   :members:
   :undoc-members:
   :show-inheritance:

Overview
--------

The ``salt3`` module implements the SALT3 model for Type Ia supernova light curves. It provides functions for computing model fluxes and bandfluxes in a differentiable way using JAX. The SALT3 model extends the SALT2 model with improved near-infrared coverage and updated training data.

The SALT3 model is defined as:

.. math::

   F(p, \lambda) = x_0 \left[ M_0(p, \lambda) + x_1 M_1(p, \lambda) \right] \times 10^{-0.4 \times c \times CL(\lambda)}

Where:

* :math:`F(p, \lambda)` is the spectral energy distribution (SED) at phase :math:`p` and wavelength :math:`\lambda`
* :math:`x_0` is the amplitude parameter
* :math:`x_1` is the stretch parameter
* :math:`c` is the color parameter
* :math:`M_0(p, \lambda)` is the mean SED component
* :math:`M_1(p, \lambda)` is the first-order variation component
* :math:`CL(\lambda)` is the color law

The module provides efficient implementations of these components, optimized for performance and differentiability.

Model Components
---------------

The SALT3 model consists of several key components:

1. **M0 Component** (`salt3_m0`): The mean SED component, representing the average Type Ia supernova spectrum as a function of phase and wavelength.

2. **M1 Component** (`salt3_m1`): The first-order variation component, which captures the primary spectral diversity of SNe Ia.

3. **Color Law** (`salt3_colorlaw`): A function that describes how the color parameter affects the SED at different wavelengths.

4. **Flux Calculation** (`salt3_flux`): Combines the components to calculate the model flux at a given phase and wavelength.

5. **Bandpass Integration** (`salt3_bandflux`): Integrates the model flux over a bandpass to calculate the observed flux.

Key Functions
------------

.. autosummary::
   :nosignatures:

   jax_supernovae.salt3.salt3_m0
   jax_supernovae.salt3.salt3_m1
   jax_supernovae.salt3.salt3_colorlaw
   jax_supernovae.salt3.salt3_flux
   jax_supernovae.salt3.salt3_bandflux
   jax_supernovae.salt3.precompute_bandflux_bridge
   jax_supernovae.salt3.optimized_salt3_bandflux
   jax_supernovae.salt3.optimized_salt3_multiband_flux
   jax_supernovae.salt3.salt3_flux

Parameters
----------

The SALT3 model has the following parameters:

* **z**: Redshift of the supernova
* **t0**: Time of peak brightness (MJD)
* **x0**: Amplitude parameter, related to the distance modulus
* **x1**: Stretch parameter, related to the light curve width
* **c**: Color parameter, related to the B-V color

These parameters are typically passed as a dictionary:

.. code-block:: python

   params = {
       'z': 0.1,      # Redshift
       't0': 58650.0, # Time of peak brightness (MJD)
       'x0': 1e-5,    # Amplitude parameter
       'x1': 0.0,     # Stretch parameter
       'c': 0.0       # Color parameter
   }

Performance Optimization
-----------------------

The module provides several optimized functions for efficient flux calculations:

* **precompute_bandflux_bridge**: Precomputes data needed for efficient bandflux calculations
* **optimized_salt3_bandflux**: Optimized version of salt3_bandflux using precomputed data
* **optimized_salt3_multiband_flux**: Calculates fluxes for multiple bands and phases efficiently

These optimized functions can provide significant speedups, especially for large datasets or when fitting many supernovae.

Example Usage
------------

Basic Example:

.. code-block:: python

   import jax
   import jax.numpy as jnp
   from jax_supernovae.salt3 import salt3_bandflux
   from jax_supernovae.bandpasses import register_bandpass, Bandpass
   
   # Enable float64 precision for better accuracy
   jax.config.update("jax_enable_x64", True)
   
   # Create a bandpass
   wave = jnp.linspace(4000, 5000, 100)
   trans = jnp.ones_like(wave)
   bandpass = Bandpass(wave=wave, trans=trans)
   
   # Register the bandpass
   register_bandpass('my_bandpass', bandpass)
   
   # Define SALT3 parameters
   params = {
       'z': 0.1,
       't0': 0.0,
       'x0': 1e-5,
       'x1': 0.0,
       'c': 0.0
   }
   
   # Compute bandflux
   time = 0.0
   flux = salt3_bandflux(time, bandpass, params)

Optimized Example:

.. code-block:: python

   import jax
   import jax.numpy as jnp
   from jax_supernovae.salt3 import precompute_bandflux_bridge, optimized_salt3_bandflux
   from jax_supernovae.bandpasses import register_bandpass, Bandpass
   
   # Enable float64 precision
   jax.config.update("jax_enable_x64", True)
   
   # Create a bandpass
   wave = jnp.linspace(4000, 5000, 100)
   trans = jnp.ones_like(wave)
   bandpass = Bandpass(wave=wave, trans=trans)
   
   # Precompute bridge data
   bridge = precompute_bandflux_bridge(bandpass)
   
   # Define SALT3 parameters
   params = {
       'z': 0.1,
       't0': 0.0,
       'x0': 1e-5,
       'x1': 0.0,
       'c': 0.0
   }
   
   # Compute bandflux using optimized function
   time = 0.0
   flux = optimized_salt3_bandflux(time, bridge['wave'], bridge['dwave'], bridge['trans'], params)

Multiple Bands Example:

.. code-block:: python

   import jax
   import jax.numpy as jnp
   from jax_supernovae.salt3 import precompute_bandflux_bridge, optimized_salt3_multiband_flux
   from jax_supernovae.bandpasses import register_bandpass, Bandpass
   
   # Enable float64 precision
   jax.config.update("jax_enable_x64", True)
   
   # Create bandpasses
   bandpasses = {}
   for name, center in [('g', 4700), ('r', 6200), ('i', 7600)]:
       wave = jnp.linspace(center - 500, center + 500, 100)
       trans = jnp.exp(-0.5 * ((wave - center) / 200)**2)
       bandpass = Bandpass(wave=wave, trans=trans)
       register_bandpass(name, bandpass)
       bandpasses[name] = bandpass
   
   # Precompute bridge data
   bridges = tuple(precompute_bandflux_bridge(bp) for bp in bandpasses.values())
   
   # Define observation times and band indices
   times = jnp.array([0.0, 1.0, 2.0, 0.0, 1.0, 2.0, 0.0, 1.0, 2.0])
   band_indices = jnp.array([0, 0, 0, 1, 1, 1, 2, 2, 2])  # 0=g, 1=r, 2=i
   
   # Define SALT3 parameters
   params = {
       'z': 0.1,
       't0': 0.0,
       'x0': 1e-5,
       'x1': 0.0,
       'c': 0.0
   }
   
   # Compute fluxes for all observations
   fluxes = optimized_salt3_multiband_flux(times, bridges, params)
   
   # Extract fluxes for each observation
   observation_fluxes = fluxes[jnp.arange(len(times)), band_indices]